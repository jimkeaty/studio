'use strict';

/**
 * Smart Broker USA ‚Äî Import Agents & Transactions
 * - Parses Excel (.xlsx)
 * - Applies locked business rules
 * - Produces agent ‚Üí year rollups
 * - DRY RUN by default
 * - Optional Firestore writes behind WRITE_TO_FIRESTORE + CONFIRM_WRITE
 *
 * Canonical Firestore shape:
 *   agents/{agentId} => { name, updatedAt }
 *   agentYearRollups/{agentId}_{year} => { agentId, year, closed, pending, listings, totals, locked, updatedAt }
 *
 * Safe staging write (single-agent tests):
 *   imports_staging/agentYear__{agentId}__{year} => { kind, agent, year, rollup, writtenAt }
 */

const fs = require('fs');
const path = require('path');
const XLSX = require('xlsx');

const admin = require('firebase-admin');

function writeFlagEnabled(v) {
  const s = String(v || '').trim().toLowerCase();
  return s === 'true' || s === '1' || s === 'yes';
}

function getDb() {
  if (!admin.apps.length) {
    admin.initializeApp({
      credential: admin.credential.applicationDefault(),
    });
  }
  return admin.firestore();
}

const CONFIG = {
  // Put your Excel file in: /imports/data/
  excelPath: process.env.EXCEL_PATH || path.join(__dirname, 'data', '2026 Version 9.xlsx'),
  sheetName: process.env.SHEET_NAME || null,

  // Governance (immutable years)
  lockedYears: new Set([2022, 2023, 2024]),

  // Counting rules
  pendingMinYear: 2026,   // Pending counted only if projected close year >= 2026
  listingsMinYear: 2025,  // Listings counted only if listing year >= 2025

  // Editable years for write preview / writes
  editableMinYear: 2025,

  // Safety switches
  writeToFirestore: writeFlagEnabled(process.env.WRITE_TO_FIRESTORE),
  confirmWrite: String(process.env.CONFIRM_WRITE || '').trim().toUpperCase() === 'YES',

  // Extra safety: prod upserts require explicit unlock
  allowProdUpsert: String(process.env.ALLOW_PROD_UPSERT || '').trim().toUpperCase() === 'YES',

  // Default: staging-only when writing (prevents touching prod unless explicitly disabled)
  stagingOnly: String(process.env.STAGING_ONLY || '').trim() !== '0',

  // Firestore collections (prod)
  collections: {
    agents: process.env.COL_AGENTS || 'agents',
    rollups: process.env.COL_ROLLUPS || 'agentYearRollups',
  },

  // Batch size for Firestore writes
  batchSize: Number(process.env.BATCH_SIZE || 450),
};

function die(msg) {
  console.error(`\n‚ùå ${msg}\n`);
  process.exit(1);
}

function isExcelSerialNumber(v) {
  return typeof v === 'number' && isFinite(v) && v > 1000 && v < 60000;
}

function parseExcelDate(v) {
  if (v === null || v === undefined || v === '') return null;
  if (v instanceof Date && !isNaN(v.getTime())) return v;

  // Excel serial date
  if (isExcelSerialNumber(v)) {
    const d = XLSX.SSF.parse_date_code(v);
    if (!d) return null;
    return new Date(Date.UTC(d.y, d.m - 1, d.d));
  }

  // Strings
  if (typeof v === 'string') {
    const s = v.trim();
    if (!s) return null;
    const d = new Date(s);
    return isNaN(d.getTime()) ? null : d;
  }

  // Fallback
  const d = new Date(v);
  return isNaN(d.getTime()) ? null : d;
}

function normalizeHeader(h) {
  return String(h || '')
    .trim()
    .toLowerCase()
    .replace(/\s+/g, ' ')
    .replace(/[^\w\s/]/g, '');
}

function normalizeRowKeys(row) {
  const out = {};
  for (const [k, v] of Object.entries(row)) out[normalizeHeader(k)] = v;
  return out;
}

function pick(row, ...keys) {
  for (const k of keys) {
    if (row[k] !== undefined && row[k] !== null && String(row[k]).trim() !== '') return row[k];
  }
  return null;
}

function yearOf(d) {
  return d ? d.getFullYear() : null;
}

/**
 * Agent cleaning:
 * - trims + collapses spaces
 * - blocks only obvious junk headers
 */
function normalizeAgentName(name) {
  const n = String(name || '').trim().replace(/\s+/g, ' ');
  if (!n) return '';
  const lower = n.toLowerCase();
  if (['agent', 'agents', 'n/a', 'na'].includes(lower)) return '';
  return n;
}

function toTitleCase(s) {
  return String(s || '')
    .toLowerCase()
    .split(' ')
    .filter(Boolean)
    .map(w => w.charAt(0).toUpperCase() + w.slice(1))
    .join(' ');
}
// ‚úÖ Agent ID corrections: bad slug ‚Üí canonical slug
const AGENT_ID_MAP = {
  "ashely-lombas": "ashley-lombas",
  "alyson-shexnayder": "alyson-schexnayder",
  "michele-ezelle": "michele-ezell",
  "michele-e": "michele-ezell",
  "madelyn-lamartinere": "madelyn-lamartiniere",
  // add more as discovered
};
// ‚úÖ Canonical display names (agentId -> correct name)
const AGENT_NAME_MAP = {
  "ashley-lombas": "Ashley Lombas",
  "alyson-schexnayder": "Alyson Schexnayder",
  "michele-ezell": "Michele Ezell",
  "madelyn-lamartiniere": "Madelyn Lamartiniere",
  // add more as discovered
};

function slugifyAgentId(agentName) {
  const clean = normalizeAgentName(agentName);
  if (!clean) return '';

  const raw = clean
    .toLowerCase()
    .replace(/['"]/g, '')
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');

  // ‚úÖ apply corrections
  return AGENT_ID_MAP[raw] || raw;
}


function ensureRollup(rollups, agent, year) {
  if (!rollups[agent]) rollups[agent] = {};
  if (!rollups[agent][year]) {
    rollups[agent][year] = {
      closed: 0,
      pending: 0,
      listings: { active: 0, canceled: 0, expired: 0 },
      totals: { transactions: 0, listings: 0, all: 0 },
    };
  }
  return rollups[agent][year];
}

function addEvent(rollups, agentRaw, year, kind) {
  const cleaned = normalizeAgentName(agentRaw);
  const agent = cleaned ? toTitleCase(cleaned) : 'Unknown Agent';
  if (!year) return;

  const r = ensureRollup(rollups, agent, year);

  if (kind === 'closed') {
    r.closed++;
    r.totals.transactions++;
    r.totals.all++;
  } else if (kind === 'pending') {
    r.pending++;
    r.totals.transactions++;
    r.totals.all++;
  } else if (kind === 'listing_active') {
    r.listings.active++;
    r.totals.listings++;
    r.totals.all++;
  } else if (kind === 'listing_canceled') {
    r.listings.canceled++;
    r.totals.listings++;
    r.totals.all++;
  } else if (kind === 'listing_expired') {
    r.listings.expired++;
    r.totals.listings++;
    r.totals.all++;
  }
}


function normalizeStatus(raw) {
  // Normalize spreadsheet status values into predictable tokens
  let s = String(raw || "").trim();
  if (!s) return "";

  // strip odd punctuation that shows up in spreadsheets
  s = s.replace(/[`"'‚Äô]/g, "");
  s = s.replace(/u00a0/g, " ");            // non-breaking space
  s = s.replace(/s+/g, " ");               // collapse whitespace
  s = s.trim().toLowerCase();

  // common ‚Äúprefix codes‚Äù in your sheet: x-, y-, z-
  if (/^[xyz]-/.test(s)) s = s.slice(2);

  // normalize british spelling
  if (s === "cancelled") s = "canceled";

  // common typos / variants
  const MAP = {
    "clsoed": "closed",
    "pendng": "pending",
    "x-cancelled": "canceled",
    "x-canceled": "canceled",
    "z-expired": "expired",
    "`pending": "pending"
  };
  if (MAP[s]) s = MAP[s];

  return s;
}

function classifyRow(nrow) {
  const statusRaw = pick(nrow, 'status', 'transaction status', 'deal status', 'listing status');
  const status = String(statusRaw || '').trim();
  const s = status.toLowerCase();

  const agent = pick(nrow, 'agent', 'agent name', 'selling agent', 'buyer agent', 'listing agent');

  // Excel truths (locked)
  const closeDate = parseExcelDate(pick(nrow, 'close date', 'closed date'));
  const projectedCloseDate = parseExcelDate(pick(nrow, 'projected close date', 'projected closing date'));
  const listingDate = parseExcelDate(
    pick(nrow, 'listing date / buyer rep date', 'listing date', 'buyer rep date')
  );

  // Closed
  if (s === 'closed') {
    if (!closeDate) return { kind: 'skip', reason: 'Closed missing Close Date' };
    return { kind: 'closed', year: yearOf(closeDate), agent };
  }

  // Pending
  if (s === 'pending') {
    if (!projectedCloseDate) return { kind: 'skip', reason: 'Pending missing Projected Close Date' };
    const y = yearOf(projectedCloseDate);
    if (y < CONFIG.pendingMinYear) return { kind: 'skip', reason: `Pending projected year < ${CONFIG.pendingMinYear}` };
    return { kind: 'pending', year: y, agent };
  }

  // Listings
  if (s === 'active' || s === 'expired' || s === 'canceled' || s === 'cancelled') {
    if (!listingDate) return { kind: 'skip', reason: 'Listing missing Listing Date / Buyer Rep Date' };
    const y = yearOf(listingDate);
    if (y < CONFIG.listingsMinYear) return { kind: 'skip', reason: `Listing year < ${CONFIG.listingsMinYear}` };

    if (s === 'expired') return { kind: 'listing_expired', year: y, agent };
    if (s === 'canceled' || s === 'cancelled') return { kind: 'listing_canceled', year: y, agent };
    return { kind: 'listing_active', year: y, agent };
  }

  return { kind: 'skip', reason: `Unhandled status: ${status}` };
}

function computeTotals(rollups) {
  const totals = {
    closed: 0,
    pending: 0,
    listings: { active: 0, canceled: 0, expired: 0 },
    totals: { transactions: 0, listings: 0, all: 0 },
  };

  for (const agent of Object.keys(rollups)) {
    for (const year of Object.keys(rollups[agent])) {
      const r = rollups[agent][year];
      totals.closed += r.closed;
      totals.pending += r.pending;
      totals.listings.active += r.listings.active;
      totals.listings.canceled += r.listings.canceled;
      totals.listings.expired += r.listings.expired;
      totals.totals.transactions += r.totals.transactions;
      totals.totals.listings += r.totals.listings;
      totals.totals.all += r.totals.all;
    }
  }

  return totals;
}

function buildWritePreview(rollups) {
  const agents = {};

  // Use a Map to guarantee 1 rollup per agentId_year
  const rollupMap = new Map(); // key => rollup object

  for (const agentName of Object.keys(rollups)) {
    const agentId = slugifyAgentId(agentName);
    if (!agentId) continue;

    const display =
      agentName === 'Unknown Agent' ? agentName : toTitleCase(agentName);

    const canonicalName = AGENT_NAME_MAP[agentId] || display;
    agents[agentId] = { name: canonicalName };

    for (const yearStr of Object.keys(rollups[agentName])) {
      const year = Number(yearStr);

      // Preview only for editable years
      if (CONFIG.lockedYears.has(year)) continue;
      if (year < CONFIG.editableMinYear) continue;

      const r = rollups[agentName][yearStr];
      const key = `${agentId}_${year}`;

      const existing = rollupMap.get(key);
      if (!existing) {
        rollupMap.set(key, {
          agentId,
          year,
          locked: false,
          closed: r.closed,
          pending: r.pending,
          listings: { ...r.listings },
          totals: { ...r.totals },
        });
      } else {
        // Merge by summing (safe if duplicates exist)
        existing.closed += r.closed;
        existing.pending += r.pending;

        existing.listings.active += r.listings.active;
        existing.listings.canceled += r.listings.canceled;
        existing.listings.expired += r.listings.expired;

        existing.totals.transactions += r.totals.transactions;
        existing.totals.listings += r.totals.listings;
        existing.totals.all += r.totals.all;
      }
    }
  }

  const agentYearRollups = Array.from(rollupMap.values());
  agentYearRollups.sort((a, b) => (a.agentId > b.agentId ? 1 : -1) || a.year - b.year);

  return { agents, agentYearRollups };
}



function validateWritePlan(preview) {
  for (const r of preview.agentYearRollups) {
    if (CONFIG.lockedYears.has(r.year)) {
      die(`Write plan includes LOCKED year ${r.year} for ${r.agentId}. Aborting.`);
    }
    if (r.year < CONFIG.editableMinYear) {
      die(`Write plan includes year ${r.year} (< ${CONFIG.editableMinYear}) for ${r.agentId}. Aborting.`);
    }
  }
}

async function writeStagingAgentYear({ agent, year, rollup }) {
  if (!CONFIG.writeToFirestore) {
    console.log("üü° WRITE_TO_FIRESTORE is OFF. No writes will occur.");
    return;
  }
  if (!CONFIG.confirmWrite) {
    console.log("üõë Safety stop: set CONFIRM_WRITE=YES to allow any Firestore write.");
    return;
  }

  const db = getDb();

  const docId = `agentYear__${agent.id}__${year}`;
  const ref = db.collection("imports_staging").doc(docId);

  const payload = {
    kind: "agent_year_rollup_staging",
    agent: { id: agent.id, name: agent.name },
    year,
    rollup,
    writtenAt: admin.firestore.FieldValue.serverTimestamp(),
  };

  await ref.set(payload, { merge: true });
  console.log(`‚úÖ STAGING WRITE OK: imports_staging/${docId}`);
}

async function writeToFirestore(preview) {
  validateWritePlan(preview);

  const agentsEntries = Object.entries(preview.agents); // [agentId, {name}]
  const rollups = preview.agentYearRollups;
  // ====== DEBUG: DUPLICATE ROLLUPS DETECTOR ======
  (function debugDuplicateRollups() {
    const ids = [];
    for (const r of rollups) {
      const id = `${r.agentId}_${r.year}`;
      ids.push(id);
    }

    const counts = ids.reduce((acc, id) => {
      acc[id] = (acc[id] || 0) + 1;
      return acc;
    }, {});

    const dupes = Object.entries(counts)
      .filter(([, c]) => c > 1)
      .sort((a, b) => b[1] - a[1]);

    if (!dupes.length) {
      console.log("‚úÖ No duplicate rollups detected.");
      return;
    }

    console.log(`‚ö†Ô∏è Duplicate rollups detected: ${dupes.length}`);
    console.log(
      dupes
        .slice(0, 50)
        .map(([id, c]) => `  - ${id}  (x${c})`)
        .join("\n")
    );

    if (dupes.length > 50) {
      console.log(`  ...and ${dupes.length - 50} more`);
    }
  })();


  console.log('\n=== FIRESTORE WRITE PLAN ===');
  console.log(`WRITE_TO_FIRESTORE: ${CONFIG.writeToFirestore ? 'true' : 'false'}`);
  console.log(`CONFIRM_WRITE: ${CONFIG.confirmWrite ? 'YES' : 'NO'}`);
  console.log(`STAGING_ONLY: ${CONFIG.stagingOnly ? 'true' : 'false'}`);
  console.log(`ALLOW_PROD_UPSERT: ${CONFIG.allowProdUpsert ? 'YES' : 'NO'}`);
  console.log(`Agents to upsert: ${agentsEntries.length}`);
  console.log(`Rollup docs to upsert (years >= ${CONFIG.editableMinYear}): ${rollups.length}`);
  console.log(`Collections (prod): agents="${CONFIG.collections.agents}", rollups="${CONFIG.collections.rollups}"`);
  console.log(`Collection (staging): imports_staging`);

  if (!CONFIG.writeToFirestore) {
    console.log('DRY RUN ‚Äî no Firestore writes.');
    return;
  }

  const LIMIT_AGENT_ID = process.env.LIMIT_AGENT_ID || "";
  const LIMIT_YEAR = process.env.LIMIT_YEAR ? Number(process.env.LIMIT_YEAR) : null;
  const agentsNeeded = new Set(
    rollups
      .filter(r => (!LIMIT_YEAR || Number(r.year) === LIMIT_YEAR))
      .map(r => r.agentId)
  );
  
  // Safety: never allow prod upsert without explicit LIMITS
  if (!CONFIG.stagingOnly && CONFIG.allowProdUpsert) {
    if (!LIMIT_YEAR) {
      die("üõë Safety stop: Prod upsert requires LIMIT_YEAR. Aborting.");
    }
  }
    
  

  // ---- STAGING WRITE (filtered) ----
  for (const r of rollups) {
    const agentId = r.agentId;
    const year = Number(r.year);

    if (!agentId || !year) continue;
    if (LIMIT_AGENT_ID && agentId !== LIMIT_AGENT_ID) continue;
    if (LIMIT_YEAR && year !== LIMIT_YEAR) continue;

    const agentInfo = preview.agents[agentId] || {};
    const agent = { id: agentId, name: agentInfo.name || "Unknown Agent" };

    await writeStagingAgentYear({ agent, year, rollup: r });
  }

  if (CONFIG.stagingOnly) {
    console.log('\n‚úÖ Staging-only mode: skipping prod upserts (agents + agentYearRollups).');
    console.log('   To enable prod upserts, set: STAGING_ONLY=0 and ALLOW_PROD_UPSERT=YES (plus CONFIRM_WRITE=YES).');
    return;
  }

  // ---- PROD UPSERTS (EXPLICITLY UNLOCKED ONLY) ----
  if (!CONFIG.allowProdUpsert) {
    console.log('\nüõë Prod upserts blocked. Set ALLOW_PROD_UPSERT=YES to enable prod writes.');
    return;
  }
  if (!CONFIG.confirmWrite) {
    console.log('\nüõë Prod upserts blocked. Set CONFIRM_WRITE=YES to enable prod writes.');
    return;
  }

  const db = getDb();
  const FieldValue = admin.firestore.FieldValue;

  let batch = db.batch();
  let ops = 0;
  let committed = 0;

  async function commitBatch() {
    if (ops === 0) return;
    await batch.commit();
    committed += ops;
    batch = db.batch();
    ops = 0;
  }

// Upsert agents (filtered)
for (const [agentId, doc] of agentsEntries) {
  if (LIMIT_AGENT_ID && agentId !== LIMIT_AGENT_ID) continue;
  if (LIMIT_YEAR && !agentsNeeded.has(agentId)) continue;

  const ref = db.collection(CONFIG.collections.agents).doc(agentId);
  batch.set(
    ref,
    { name: doc.name, updatedAt: FieldValue.serverTimestamp() },
    { merge: true }
  );
  ops++;
  if (ops >= CONFIG.batchSize) await commitBatch();
}

  // Upsert rollups (filtered)
  for (const r of rollups) {
    if (LIMIT_AGENT_ID && r.agentId !== LIMIT_AGENT_ID) continue;
    if (LIMIT_YEAR && Number(r.year) !== LIMIT_YEAR) continue;

    const docId = `${r.agentId}_${r.year}`;
    const ref = db.collection(CONFIG.collections.rollups).doc(docId);
    batch.set(
      ref,
      {
        agentId: r.agentId,
        year: r.year,
        locked: false,
        closed: r.closed,
        pending: r.pending,
        listings: r.listings,
        totals: r.totals,
        updatedAt: FieldValue.serverTimestamp(),
      },
      { merge: true }
    );
    ops++;
    if (ops >= CONFIG.batchSize) await commitBatch();
  }

  await commitBatch();
  console.log(`\n‚úÖ Firestore prod upsert complete. Ops committed: ${committed}`);
}

(function main() {
  (async () => {
    console.log('\n=== Smart Broker USA Importer ===');
    console.log(`Excel: ${CONFIG.excelPath}`);
    console.log(`WRITE_TO_FIRESTORE: ${CONFIG.writeToFirestore ? 'true' : 'false'}`);
    console.log(`CONFIRM_WRITE: ${CONFIG.confirmWrite ? 'YES' : 'NO'}`);
    console.log(`STAGING_ONLY: ${CONFIG.stagingOnly ? 'true' : 'false'}`);
    console.log(`ALLOW_PROD_UPSERT: ${CONFIG.allowProdUpsert ? 'YES' : 'NO'}`);

    if (!fs.existsSync(CONFIG.excelPath)) {
      die(
        `Excel file not found at: ${CONFIG.excelPath}\n` +
        `Put it at /imports/data/ or set EXCEL_PATH env var.`
      );
    }

    const wb = XLSX.readFile(CONFIG.excelPath, { cellDates: false });
    const sheetName = CONFIG.sheetName || wb.SheetNames[0];
    const ws = wb.Sheets[sheetName];
    if (!ws) die(`Sheet not found: ${sheetName}`);

    const rawRows = XLSX.utils.sheet_to_json(ws, { defval: null });
    console.log(`Sheet: ${sheetName}`);
    console.log(`Rows: ${rawRows.length}`);

    const rollups = {};
    const counters = {
      closed: 0,
      pending: 0,
      listing_active: 0,
      listing_canceled: 0,
      listing_expired: 0,
      skipped: 0,
      skippedReasons: {},
    };

    for (const row of rawRows) {
      const nrow = normalizeRowKeys(row);
      const c = classifyRow(nrow);

      if (c.kind === 'skip') {
        counters.skipped++;
        counters.skippedReasons[c.reason] = (counters.skippedReasons[c.reason] || 0) + 1;
        continue;
      }

      counters[c.kind]++;
      addEvent(rollups, c.agent, c.year, c.kind);
    }

    console.log('\n=== COUNTS ===');
    console.log(JSON.stringify(counters, null, 2));

    const flat = [];
    for (const agent of Object.keys(rollups)) {
      for (const year of Object.keys(rollups[agent])) {
        const r = rollups[agent][year];
        flat.push({
          agent,
          year: Number(year),
          all: r.totals.all,
          closed: r.closed,
          pending: r.pending,
          listingActive: r.listings.active,
          listingCanceled: r.listings.canceled,
          listingExpired: r.listings.expired,
        });
      }
    }
    flat.sort((a, b) => b.all - a.all);

    console.log('\n=== TOP 10 AGENT-YEAR ROLLUPS ===');
    console.table(flat.slice(0, 10));

    console.log('\n=== TOTALS ===');
    console.log(JSON.stringify(computeTotals(rollups), null, 2));

    // Debug: Unknown Agent audit
    if (rollups['Unknown Agent']) {
      const years = Object.keys(rollups['Unknown Agent']).sort();
      const summary = years.map(y => ({
        year: Number(y),
        closed: rollups['Unknown Agent'][y].closed,
        pending: rollups['Unknown Agent'][y].pending,
        listingActive: rollups['Unknown Agent'][y].listings.active,
        listingCanceled: rollups['Unknown Agent'][y].listings.canceled,
        listingExpired: rollups['Unknown Agent'][y].listings.expired,
        all: rollups['Unknown Agent'][y].totals.all,
      }));
      const totalUnknown = summary.reduce((acc, r) => acc + r.all, 0);
      console.log('\n=== UNKNOWN AGENT AUDIT ===');
      console.log(`Total Unknown Agent rows counted: ${totalUnknown}`);
      console.table(summary);
    } else {
      console.log('\n=== UNKNOWN AGENT AUDIT ===');
      console.log('No Unknown Agent rows counted.');
    }

    console.log('\n=== FIRESTORE WRITE PREVIEW (DRY RUN ‚Äî NO WRITES) ===');
    const preview = buildWritePreview(rollups);
    console.log(`Preview agents: ${Object.keys(preview.agents).length}`);
    console.log(`Preview rollup docs (years >= ${CONFIG.editableMinYear}): ${preview.agentYearRollups.length}`);

    console.log(JSON.stringify(preview, null, 2).slice(0, 4000));
    console.log('\n(Note: preview truncated for readability)');

      // Always run write plan + duplicate detector.
      // writeToFirestore() safely exits early when WRITE_TO_FIRESTORE is OFF.
      await writeToFirestore(preview);

    console.log('\n‚úÖ Done.');
  })().catch(err => {
    console.error('\n‚ùå Fatal error:', err);
    process.exit(1);
  });
})();
